#!/usr/bin/env python
# $Id$
# A routine to plot the output of the ord apps.
#

import sys, string, time, datetime, numpy, matplotlib, pylab

def main():
    from optparse import OptionParser
    parser = OptionParser()
    parser.add_option("-d", "--debug", help="Increase the debugLevel", \
                      default=0, dest="debugLevel", action="count")

    parser.add_option("-i", help="Input data file, defaults to stdin.", \
                      dest="inputFile", type="string", action="store")

    parser.add_option("-t", help="Specify a title for the plot. "+\
                      "Defaults to the name of the input stream.", \
                      dest="title", type="string", action="store")

    parser.add_option("-l", "--legend", dest="legend", action="count",
                      help="Include a legend.")

    parser.add_option("-f", dest="saveFig", action="store", type="string",\
                      help="Save the figure to the indicated file")

    parser.add_option("-y", dest="yRange", action="store", type="float",\
                      help="Fix the y range on the ords to be +- this value.")
                      
    parser.add_option("-s", dest="tStart", action="store",\
                      help="Start time. Format as \"YYYY DOY HH:MM:SS.S\" (Note\
                      the trailing decimal place).") 

    parser.add_option("-e", dest="tEnd", action="store",\
                      help="End time. Format as \"YYYY DOY HH:MM:SS.S\" (Note\
                      the trailing decimal place).") 

    parser.add_option("-w", "--warts",\
                      dest="wartiness", action="count",\
                      help="Increase the importants of warts on the plot.\
                      Zero (the default) means don't even plot them. One\
                      means plot them but don't autoscale to show them all\
                      (just show all the ords). Two means autoscale to show\
                      all the warts. Three means only show the warts and\
                      don't show any ords. Only zero and 2 have been\
                      implimented.")                 


    (options, args) = parser.parse_args()

    if (len(args) and options.inputFile == None):
        options.inputFile = args[0]

    inputFile = sys.stdin
    if (options.inputFile):
        inputFile = open(options.inputFile)

    if (options.title == None):
        options.title = inputFile.name

    if (options.debugLevel):
        print "Processing: %s" % inputFile.name
        print "Debug level: %d" % options.debugLevel
        print "Title: %s" % options.title
        if options.yRange:
            print "Fixing y axis to +/- %.f meters" % options.yRange

    # ------------------------------------------------------------------
    # Here we start reading in the raw double differences
    #      time, doubleDifference, prn1, el1, prn2, el2
    dataList = ([], [], [], [], [], [])
    for line in inputFile:
        line = line.strip()
        if options.debugLevel>1:
            print line
        if len(line)==0: continue

        if line[0] == "#": continue
        if line[0] == '>': continue

        words=line.split()
        
        t = parse_time(words[0:3])
        ordType = "%s %s %s"%(words[3], words[4], words[5])
        sv1 = int(words[6])
        sv2 = int(words[7])
        elev1 = float(words[8])
        elev2 = float(words[9])
        ddr = float(words[10])
        h = int(words[11],16)
        dataList[0].append(t)
        dataList[1].append(ddr)
        dataList[2].append(sv1)
        dataList[3].append(sv2)
        dataList[4].append(elev1)
        dataList[5].append(elev2)


    data = numpy.array(dataList)
    del dataList
    # make sure that there is some data to plot
    if data.shape[1] < 1:
        exit;

    # done reading in the ord file
    # ------------------------------------------------------------------

    # A key handler for matplotlib
    def press(event):
        if event.key=='q' or event.key==' ':
            pylab.close()


    # Here we start generating the plots
    fig = pylab.figure()
    pylab.connect('key_press_event', press)
    yprops = dict(rotation=90,
                  horizontalalignment='right',
                  verticalalignment='center',
                  family='monospace',
                  x=-0.01)

    scale_props = dict(horizontalalignment="right",
                       verticalalignment="bottom",
                       size=8, family="sans-serif")

    xMajorFmt=pylab.DateFormatter("%02H:%02M\n%03j")
    xMinorFmt=pylab.NullFormatter()
    xMajorLoc=matplotlib.dates.DayLocator()
    xMinorLoc=matplotlib.dates.HourLocator()

    rExtent=0.89
    if options.legend:
        rExtent=0.82

    ax1 = fig.add_axes([0.08, 0.10, 0.9, 0.85])

    ax1.plot_date(data[0], data[1], 'g,', label="double differences")
    if options.legend:
        ax1.legend(numpoints=2, pad=0.1, labelsep = 0, handlelen=0.005,
                   handletextsep=0.01, axespad=0.0, loc=(1,0))
        leg = pylab.gca().get_legend()
        ltext = leg.get_texts()
        llines = leg.get_lines()
        lframe = leg.get_frame()
        lframe.set_facecolor('0.4')

    ax1.set_ylabel('ord (meters)', **yprops)
    ax1.grid(True)
    if options.yRange:
        ax1.set_ylim(ymin=-options.yRange, ymax=options.yRange)
    else:
        pylab.figtext(rExtent+.08, 0.95, "y range autoscaled",
                      **scale_props)
    ax1.xaxis.set_major_formatter(xMajorFmt)
    xlabels=ax1.get_xticklabels()
    ylabels=ax1.get_yticklabels()
    pylab.setp(xlabels, fontsize=10, family='sans-serif')
    pylab.setp(ylabels, fontsize=10, family='sans-serif')
    ax1.xaxis.set_minor_formatter(xMinorFmt)

    # set x axis range
    if options.tStart:
      tMin = parse_time(options.tStart.split()[0:3])
    else:
      tMin = min(data[0])

    if options.tEnd:
      tMax = parse_time(options.tEnd.split()[0:3])
    else:
      tMax = max(data[0])

    ax1.set_xlim(xmin=tMin, xmax=tMax)
    ax1.set_title(options.title)

    if (options.saveFig == None):
        pylab.show()
    else:
       pylab.savefig(options.saveFig)
# end of main


def parse_time(words):
    fsec = float(words[2][8:10])
    ydhms =  words[0]+" "+words[1]+" "+words[2][0:8]
    utime = time.strptime(ydhms, "%Y %j %H:%M:%S")
    dtime = datetime.datetime(utime[0], utime[1], utime[2],
                              utime[3], utime[4], utime[5], int(fsec*1e6))
    t0 = matplotlib.dates.date2num(dtime)
    return t0
# end of parse_time()

    
if __name__ == "__main__":
    main()
