#pragma ident "$Id"

/*
Program to perform Hilbert transform on samples from output file generated by SiGe SE4110L.  The SiGe chip outputs real 2-bit samples.  The GPSCreations GPS1A board ships with a program "ogusb-lit60.exe" that outputs the samples in char format to a file.  This program reads from such a file, performs the Hilbert transform, and outputs I and Q samples in a 2-bit IQStream used by the GPStk.  

Requires the FFTW library.
*/

#include <iostream>
#include <stdio.h>
#include <math.h> 
#include <complex>
#include <fftw3.h>
#include <vector>

#include "BasicFramework.hpp"
#include "IQStream.hpp"

using namespace gpstk;
using namespace std;

int main(int argc, char *argv[])
{
   int N = 90000;
   
   FILE * in;
   char R[N];


   fftw_complex *REAL;
   fftw_complex *IQ;
   fftw_complex *X;
   fftw_plan p;  

   IQStream *output = new IQ2Stream();

   using std::basic_ios;              // Set up IQStream
   output->copyfmt(std::cout);
   output->clear(std::cout.rdstate());
   output->basic_ios<char>::rdbuf(std::cout.rdbuf());
   output->filename = "<stdout>";


   REAL = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); // input
   IQ = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); // final output
   X = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); // intermediate
   p = fftw_plan_dft_1d(N, REAL, X, FFTW_FORWARD, FFTW_ESTIMATE); //FFT plan

   in = fopen("2008-159-1359.bin","rb");
   if(in==NULL)
   {  cerr << "Could not open input file, exiting..." << endl;
      return 0;}

/*
   // Sloppy way to get samples from middle of file.
   char throwAway;
   for(int i = 0; i < 16368 * 300; i++)
   {
      throwAway = fgetc(in);
   }
*/   

   // Read data into input array.
   for(int i=0 ; i < N ; i++) 
   {
         R[i] = fgetc(in);
         REAL[i][0] = R[i];
         REAL[i][1] = 0.0;
   }

   // Execute FFT.
   fftw_execute(p);  

   // Create new Hilbert components.
   if(N%2 == 0)      
   {
      for(int i=(N/2 + 1) ; i < N ; i++)
      {
         X[i][0] = 0.0; 
         X[i][1] = 0.0;
      }
      for(int i=1; i < (N/2 - 1) ; i++)
      {
         X[i][0] *= 2.0;
         X[i][1] *= 2.0;
      }
   }
   else
   {
      for(int i=((N+1)/2) ; i < N ; i++)
      {
         X[i][0] = 0.0; 
         X[i][1] = 0.0;
      }
      for(int i=1; i < (N-1)/2 ; i++)
      {
         X[i][0] *= 2.0;
         X[i][1] *= 2.0;
      }
   }

   // Execute Backward FFT.
   p = fftw_plan_dft_1d(N, X, IQ, FFTW_BACKWARD, FFTW_ESTIMATE); 
   fftw_execute(p); 

   for(int i=0 ; i < N ; i++)
   {  
      IQ[i][0] =   (  2 * IQ[i][0] / N) ;
      IQ[i][1] =   (  2 * IQ[i][1] / N) ;
         //cout << IQ[i][0] << " " << IQ[i][1] <<endl;
   }

   // Output I and Q samples to IQStream.
   complex<float> o[N];
   for(int i=0; i < N; i++)
   {
      o[N] = complex<float>(IQ[i][0],IQ[i][1]);
      *output << o[N];
   }

/*
   // Output without performing Hilbert transform (real only)
   complex<short> o[N];
   for(int i=0; i < N; i++)
   {
      o[N] = complex<short>(R[i],0);
      *output << o[N];
   }
*/

   fftw_destroy_plan(p);
   fftw_free(REAL); fftw_free(IQ); fftw_free(X);
}
