#pragma ident "$Id$"

/*
Program to perform Hilbert transform on samples from output file generated by SiGe SE4110L.  The SiGe chip outputs real 2-bit samples.  The GPSCreations GPS1A board ships with a program "ogusb-lit60.exe" that outputs the samples in char format to a file.  This program reads from such a file, performs the Hilbert transform, and outputs I and Q samples in a 2-bit IQStream used by the GPStk.  

Requires the FFTW library.

The SiGe data sheet shows the IF at 4.092 MHz. in the current configuration, but OSGPS claims it is 4.13 MHz. and that seems to be correct.  The SiGe sampling rate is 16.368 MHz.


GCC: (not added to Jamfile yet, since this links to FFTW)
g++ -c -o hilbert.o -O -I. -I/.../gpstk/dev/apps/swrx -I/.../gpstk/dev/src hilbert.cpp

g++ -o hilbert hilbert.o /.../gpstk/dev/apps/swrx/simlib.a /.../gpstk/dev/src/libgpstk.a -lm -lstdc++ -lfftw3 -lm

*/

#include <iostream>
#include <stdio.h>
#include <math.h> 
#include <complex>
#include <fftw3.h>
#include <vector>

#include "BasicFramework.hpp"
#include "IQStream.hpp"

using namespace gpstk;
using namespace std;

int main(int argc, char *argv[])
{
   int N = 16; // Number of samples per transform.
   int count = 0;
   long int total = 16368*59000; // Total number of samples.
      // This is about the number of samples from a 60 sec SiGe file..
   
   FILE * in;
   char R[N];


   fftw_complex *REAL; // Real input.
   fftw_complex *IQ; // I and Q output.
   fftw_complex *X; // Intermediate, data in freq domain.
   fftw_plan p,pb;  // FFTW plans

   IQStream *output = new IQ2Stream();
   using std::basic_ios;              // Set up IQStream
   output->copyfmt(std::cout);
   output->clear(std::cout.rdstate());
   output->basic_ios<char>::rdbuf(std::cout.rdbuf());
   output->filename = "<stdout>";


   REAL = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); 
   IQ = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); 
   X = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); 
   p = fftw_plan_dft_1d(N, REAL, X, FFTW_FORWARD, FFTW_MEASURE);
   pb = fftw_plan_dft_1d(N, X, IQ, FFTW_BACKWARD, FFTW_MEASURE);

   in = fopen("gnssGood.bin","rb");
   if(in==NULL)
   {  cerr << "Could not open input file, exiting..." << endl;
      return 0;}

/*
   // Sloppy way to get samples from middle of file.
   char throwAway;
   for(int i = 0; i < 16368 * 2000; i++)
   {
      throwAway = fgetc(in);
   }
*/

   while(count < total)
   {
      
      // Read data into input array.
      for(int i=0 ; i < N ; i++) 
      {
         R[i] = fgetc(in);
         REAL[i][0] = R[i];
         REAL[i][1] = 0.0;
      }

      // Execute FFT.
      fftw_execute(p);  

      // Create new Hilbert components.
      if(N%2 == 0)      // Even N
      {
         for(int i=(N/2 + 1) ; i < N ; i++)
         {
            X[i][0] = 0.0; 
            X[i][1] = 0.0;
         }
         for(int i=1; i < (N/2 - 1) ; i++)
         {
            X[i][0] *= 2.0;
            X[i][1] *= 2.0;
         }
      }
      else              // Odd N.
      {
         for(int i=((N+1)/2) ; i < N ; i++)
         {
            X[i][0] = 0.0; 
            X[i][1] = 0.0;
         }
         for(int i=1; i < (N-1)/2 ; i++)
         {
            X[i][0] *= 2.0;
            X[i][1] *= 2.0;
         }
      }

      // Execute Backward FFT.
      fftw_execute(pb); 

      for(int i=0 ; i < N ; i++)
      {  
         IQ[i][0] =   (  2 * IQ[i][0] / N ) ;
         IQ[i][1] =   (  2 * IQ[i][1] / N ) ;
      }

      // Output I and Q samples to IQStream.
      complex<float> o[N];
      for(int i=0; i < N; i++)
      {
         o[i] = complex<float>(IQ[i][0],IQ[i][1]);
         *output << o[i];
      }
      count+=N;
   } // end while
   
/*
   // Output without performing Hilbert transform (real only)
   complex<short> o[N];
   for(int i=0; i < N; i++)
   {
      o[N] = complex<short>(R[i],0);
      *output << o[N];
   }
*/

   fftw_destroy_plan(p);fftw_destroy_plan(pb);
   fftw_free(REAL); fftw_free(IQ); fftw_free(X);
}
