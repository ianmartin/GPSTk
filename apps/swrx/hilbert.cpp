#pragma ident "$Id$"

/*
Program to perform Hilbert transform on samples from output file generated by SiGe SE4110L.  The SiGe chip outputs real 2-bit samples.  The GPSCreations GPS1A board ships with a program "ogusb-lit60.exe" that outputs the samples in char format to a file.  This program reads from such a file, performs the Hilbert transform, and outputs I and Q samples in a 2-bit IQStream used by the GPStk.

The effective sampling rate is cut in half because N points of real data generate N/2 points of complex data.  

Requires the FFTW library.

GCC: (not added to Jamfile yet, since this links to FFTW)
g++ -c -o hilbert.o -O -I. -I/.../gpstk/dev/apps/swrx -I/.../gpstk/dev/src hilbert.cpp

g++ -o hilbert hilbert.o /.../gpstk/dev/apps/swrx/simlib.a /.../gpstk/dev/src/libgpstk.a -lm -lstdc++ -lfftw3 -lm

*/

#include <iostream>
#include <stdio.h>
#include <math.h> 
#include <complex>
#include <fftw3.h>
#include <vector>
#include <CommandOption.hpp>
#include <CommandOptionParser.hpp>

#include "BasicFramework.hpp"
#include "IQStream.hpp"

using namespace gpstk;
using namespace std;
using namespace gpstk::StringUtils;

int main(int argc, char *argv[])
{
   CommandOptionWithAnyArg
      inputOpt('i', "input", "Location of input data file.",true);
   CommandOptionNoArg
      helpOption('h', "help", "Print usage. Repeat for more info. ");

   CommandOptionWithAnyArg
      timeOpt('t', "number-samples", "Number of C/A periods to input.");
   
   string appDesc("Performs hilbert transform on GPS1A data.");
   CommandOptionParser cop(appDesc);
   cop.parseOptions(argc, argv);

   if (helpOption.getCount() || cop.hasErrors())
   {
      if (cop.hasErrors() && helpOption.getCount()==0)
      {
         cop.dumpErrors(cout);
         cout << "Use -h for help." << endl;
      }
      else
      {
         cop.displayUsage(cout);
      }
      exit(0);
   } 

   char f[] = "";
   sprintf(f,inputOpt.getValue()[0].c_str());
   FILE * in = fopen(f,"rb");
   if(in==NULL)
   {  cerr << "Could not open input file, exiting..." << endl;
      return 0;}

   int numPeriods=59000;
   if(timeOpt.getCount())
   {numPeriods=asInt(timeOpt.getValue().front());}

//---------------------------------------------------------------------------
//---------------------------------------------------------------------------
   int N = 64; // Default number of samples per transform.
   int N2 = N/2;
   int count = 0;
   long int total = 16368*numPeriods;

   char R[N];
   double *REAL;
   fftw_complex *IQ;
   fftw_complex *X;
   fftw_complex *X1;
   fftw_plan p,pb;

   IQStream *output = new IQ2Stream();

   using std::basic_ios;              // Set up IQStream
   output->copyfmt(std::cout);
   output->clear(std::cout.rdstate());
   output->basic_ios<char>::rdbuf(std::cout.rdbuf());
   output->filename = "<stdout>";


   REAL = (double*) malloc(sizeof(double) * N); // input
   IQ = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N2); // final output
   X = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N); // intermediate
   X1 = (fftw_complex*) fftw_malloc(sizeof(fftw_complex) * N2);
   p = fftw_plan_dft_r2c_1d(N, REAL, X, FFTW_MEASURE); //FFT plan
   pb = fftw_plan_dft_1d(N2, X1, IQ, FFTW_BACKWARD, FFTW_MEASURE);

/*
   // Sloppy way to get samples from middle of file.
   char throwAway;
   for(int i = 0; i < 16368 * 2000; i++)
   {
      throwAway = fgetc(in);
   }
*/

   while(count < total)
   {
      if(feof(in))
      {
         fftw_destroy_plan(p);fftw_destroy_plan(pb);
         fftw_free(REAL); fftw_free(IQ); fftw_free(X);
         return 0;
      }
      // Read data into input array.
      for(int i=0 ; i < N ; i++) 
      {
         R[i] = fgetc(in);
         REAL[i] = R[i];
      }

      // Execute FFT.
      fftw_execute(p);

      // Create new Hilbert components.
      for(int i=0; i < ( N/2 - 1 ) ; i++)
      {
         X1[i][0] = X[i][0];
         X1[i][1] = X[i][1];
      }
      
      // Execute Backward FFT.
      fftw_execute(pb); 

      for(int i=0 ; i < N2 ; i++)
      {  
         IQ[i][0] =   (  IQ[i][0] / N2 ) ;
         IQ[i][1] =   (  IQ[i][1] / N2 ) ;
      }

      // Output I and Q samples to IQStream.
      complex<float> o[N2];
      for(int i=0; i < (N2); i++)
      {
         o[i] = complex<float>(IQ[i][0],IQ[i][1]);
         *output << o[i];
      }
      count+=N;
   }//while  


   fftw_destroy_plan(p);fftw_destroy_plan(pb);
   fftw_free(REAL); fftw_free(IQ); fftw_free(X);
}
